{
  "version": 3,
  "sources": ["worker:D:\\data_ferdi\\application\\xml-xsd_validation-browser\\dist\\esm\\worker\\validator.worker", "../../dist/esm/libxml/libxmlloader.js", "../../dist/esm/validateFormWell.js", "../../dist/esm/provider/MapInputProvider.js", "../../dist/esm/util/helper.js", "../../dist/esm/validateTowardXsd.js", "../../dist/esm/validate.js", "../test.ts"],
  "sourcesContent": ["\n          export default function WorkerWrapper() {\n            return new Worker(new URL(\"./validator.worker.js\", import.meta.url), { type: \"module\" });\n          }\n        ", "export const loader = {\n    libxml: null,\n    // loadingPromise: null as Promise<void> | null,\n    initError: null,\n};\nexport function libxml() {\n    return loader.libxml;\n}\nexport async function ensureLibxml2Loaded() {\n    return new Promise(async (resolve, reject) => {\n        if (loader.libxml || loader.initError)\n            return resolve([]);\n        try {\n            // globalThis.process = undefined;\n            // const mod = await import(\"../../libxml2-wasm/lib/index.mjs\");\n            // const mod = await import(\"https://ferdisap.github.io/xml-xsd_validator-browser/libxml2-wasm/lib/index.mjs\");\n            // const mod = await import(\"../../node_modules/libxml2-wasm/lib/index.mjs\");\n            const mod = (await import(\"https://ferdisap.github.io/xml-xsd_validator-browser/libxml2-wasm/lib/index.mjs\"));\n            loader.libxml = mod;\n            // loader.libxml = await mod(); \n            // console.log(loader.libxml)\n            return resolve([]);\n        }\n        catch (e) {\n            loader.initError = e;\n            loader.initError.data = [{\n                    name: \"LibInitError\",\n                    type: \"none\",\n                    details: {\n                        message: loader.initError?.message || String(loader.initError),\n                        file: \"\",\n                        line: 1,\n                        col: 1\n                    }\n                }];\n            return reject(loader.initError);\n        }\n    });\n}\n// export async function ensureLibxml2Loaded() {\n//   if (loader.libxml || loader.initError) return;\n//   if (loader.loadingPromise) return loader.loadingPromise;\n//   loader.loadingPromise = (async () => {\n//     try {\n//       const instance = await init_lib(); // <\u2014 ini penting\n//       loader.libxml = instance;          // <\u2014 simpan hasil inisialisasi\n//       // console.log(\"[libxml2] loaded:\", Object.keys(instance));\n//     } catch (e) {\n//       console.error(\"[libxml2] init error:\", e);\n//       loader.initError = e;\n//       loader.initError.data = [\n//         {\n//           name: \"LibInitError\",\n//           type: \"none\",\n//           details: {\n//             message: loader.initError?.message || String(loader.initError),\n//             file: \"\",\n//             line: 1,\n//             col: 1,\n//           },\n//         },\n//       ];\n//       throw e;\n//     }\n//   })();\n//   await loader.loadingPromise;\n// }\n/**\n * Ensure libxml2-wasm is initialized before use.\n * Adds timeout protection in worker context to avoid infinite pending state.\n */\n// export async function ensureLibxml2Loaded(): Promise<ValidationInfo[]> {\n//   if (loader.libxml || loader.initError) return [];\n//   if (loader.loadingPromise) {\n//     await loader.loadingPromise;\n//     return [];\n//   }\n//   loader.loadingPromise = (async () => {\n//     try {\n//       console.log(\"[worker] ensureLibxml2Loaded: init_lib() start\");\n//       // Tambahkan timeout (misalnya 5 detik)\n//       const timeout = new Promise<never>((_, reject) =>\n//         setTimeout(() => reject(new Error(\"libxml2 init timeout\")), 5000)\n//       );\n//       await Promise.race([init_lib(), timeout]);\n//       console.log(\"[worker] ensureLibxml2Loaded: init_lib() done\");\n//       loader.libxml = lib_exports;\n//       console.log(loader.libxml ? 'fufu' : 'fafa', loader.libxml)\n//     } catch (e) {\n//       loader.initError = e;\n//       loader.initError.data = [\n//         {\n//           name: \"LibInitError\",\n//           type: \"none\",\n//           details: {\n//             message: loader.initError?.message || String(loader.initError),\n//             file: \"\",\n//             line: 1,\n//             col: 1,\n//           },\n//         },\n//       ];\n//       throw e;\n//     }\n//   })();\n//   try {\n//     await loader.loadingPromise;\n//     return [];\n//   } finally {\n//     delete loader.loadingPromise;\n//   }\n// }\nexport function useLibXml2() {\n    return {\n        libxml, ensureLibxmlLoaded: ensureLibxml2Loaded\n    };\n}\n// import { ValidationInfo, WorkerBags } from \"./types\";\n// type LibLoader = {\n//   libxml: any | null,\n//   initError: any | null,\n// }\n// const loader:LibLoader = {\n//   libxml: null,\n//   initError: null,\n// }\n// function libxml(){\n//   return loader.libxml;\n// }\n// /**\n//  * To ensure that libxml2 has loaded, to let the worker can process.\n//  * @returns Promise array contains validation info or an error instance of XmlError or XmlValidateError owned by libxml2-wasm\n//  */\n// export async function ensureLibxml2Loaded(): Promise<ValidationInfo[]> {\n//   return new Promise(async (resolve, reject) => {\n//     if ((loader).libxml || loader.initError) return resolve([]);\n//     try {\n//       // dynamic import to avoid bundler import shape issues\n//       const mod = await import(\"libxml2-wasm\");\n//       (loader).libxml = mod;\n//       return resolve([]);\n//       // Note: libxml2.mjs already runs moduleLoader() at top-level (it awaits moduleLoader)\n//       // so simply importing gives us ready exports.\n//     } catch (e) {\n//       loader.initError = e;\n//       loader.initError.data = [{\n//         name: \"LibInitError\",\n//         type: \"none\",\n//         details: {\n//           message: loader.initError?.message || String(loader.initError),\n//           file: \"\",\n//           line: 1,\n//           col: 1,\n//         }\n//       }]\n//       return reject(loader.initError);\n//     }\n//   })\n// }\n// export function useLibXml2(){\n//   return {\n//     libxml, ensureLibxmlLoaded: ensureLibxml2Loaded\n//   }\n// }\n", "import { useLibXml2 } from \"./libxml/libxmlloader\";\n/**\n * \u2705 Validasi XML hanya untuk memastikan well-formed\n * - Menggunakan libxml2-wasm (WASM, aman di Worker)\n * - Output sesuai struktur ValidationErrorInfo\n */\nexport async function validateWellForm(xmlText) {\n    const errorBags = [];\n    const { libxml, ensureLibxmlLoaded } = useLibXml2();\n    return ensureLibxmlLoaded()\n        .then(() => {\n        libxml().XmlDocument.fromString(xmlText);\n        return Promise.resolve([]);\n    })\n        .catch((err) => {\n        // to check wheer err is instance of XMlParseError. Use attribute details because class instance cannot used in worker\n        if (err.details) {\n            const detail = err.details || {};\n            errorBags.push({\n                name: \"XMLParseError\",\n                type: \"form\",\n                detail: {\n                    message: detail.message || err.message || \"Invalid XML format\",\n                    file: detail.file || \"\",\n                    line: detail.line?.toString() || 1,\n                    col: detail.col?.toString() || 1,\n                },\n            });\n        }\n        else {\n            if (err.data)\n                errorBags.push(...err.data);\n            errorBags.push({\n                name: \"UnknownError\",\n                type: \"form\",\n                detail: {\n                    message: err?.message || String(err),\n                    file: \"\",\n                    line: 1,\n                    col: 1,\n                },\n            });\n        }\n        return Promise.reject(errorBags);\n    });\n}\n", "// import {\n//   xmlRegisterInputProvider,\n//   xmlCleanupInputProvider,\n// } from \"libxml2-wasm\";\nimport { useLibXml2 } from \"../libxml/libxmlloader\";\n/**\n * Create a virtual file provider for libxml2-wasm.\n * It maps filenames (or URLs) to in-memory schema contents,\n * allowing libxml2 to resolve xs:import/xs:include directly\n * without needing network access.\n */\nexport async function createMapInputProvider(map) {\n    const { libxml, ensureLibxmlLoaded } = useLibXml2();\n    await ensureLibxmlLoaded();\n    const xmlRegisterInputProvider = libxml().xmlRegisterInputProvider;\n    const xmlCleanupInputProvider = libxml().xmlCleanupInputProvider;\n    const store = new Map();\n    const handles = new Map();\n    let nextFd = 1;\n    // --- utilities ---\n    const toUint8 = (s) => new TextEncoder().encode(s);\n    const normalizeKey = (k) => {\n        if (!k)\n            return k;\n        try {\n            const u = new URL(k);\n            return u.href;\n        }\n        catch {\n            return k;\n        }\n    };\n    const basename = (path) => {\n        try {\n            const u = new URL(path);\n            return u.pathname.split(\"/\").pop() || path;\n        }\n        catch {\n            const parts = path.split(\"/\");\n            return parts[parts.length - 1] || path;\n        }\n    };\n    // --- initialize store ---\n    if (map instanceof Map) {\n        for (const [k, v] of map.entries())\n            store.set(normalizeKey(k), toUint8(v));\n    }\n    else {\n        for (const { filename, contents } of map)\n            store.set(normalizeKey(filename), toUint8(contents));\n    }\n    // Also add basenames for fallback\n    for (const key of Array.from(store.keys())) {\n        const base = basename(key);\n        if (!store.has(base)) {\n            store.set(base, store.get(key));\n        }\n    }\n    // --- provider implementation ---\n    const match = (filename) => {\n        if (!filename)\n            return false;\n        const n = normalizeKey(filename);\n        if (store.has(n))\n            return true;\n        const base = basename(n);\n        if (store.has(base))\n            return true;\n        for (const k of store.keys()) {\n            if (n.endsWith(k) || k.endsWith(n))\n                return true;\n        }\n        return false;\n    };\n    const open = (filename) => {\n        const n = normalizeKey(filename);\n        let data = store.get(n);\n        if (!data) {\n            const base = basename(n);\n            data = store.get(base);\n        }\n        if (!data) {\n            for (const [k, v] of store.entries()) {\n                if (n.endsWith(k) || k.endsWith(n)) {\n                    data = v;\n                    break;\n                }\n            }\n        }\n        if (!data)\n            return undefined;\n        const fd = nextFd++;\n        handles.set(fd, { pos: 0, data });\n        return fd;\n    };\n    const read = (fd, buf) => {\n        const h = handles.get(fd);\n        if (!h)\n            return -1;\n        const remaining = h.data.length - h.pos;\n        if (remaining <= 0)\n            return 0;\n        const toCopy = Math.min(buf.byteLength, remaining);\n        buf.set(h.data.subarray(h.pos, h.pos + toCopy), 0);\n        h.pos += toCopy;\n        return toCopy;\n    };\n    const close = (fd) => handles.delete(fd);\n    // --- register / cleanup ---\n    const register = () => {\n        return xmlRegisterInputProvider({\n            match,\n            open,\n            read,\n            close,\n        });\n    };\n    const cleanup = () => {\n        xmlCleanupInputProvider();\n    };\n    // expose methods\n    return {\n        match,\n        open,\n        read,\n        close,\n        register,\n        cleanup,\n    };\n}\n", "/**\n * Rekursif mendeteksi semua dependency XSD dari schema utama,\n * handle xs:import, xs:include, dan xs:redefine\n *\n * Tidak menggunakan async/await, seluruhnya Promise chaining.\n * Menangani error dengan console.error, tetap resolve agar tidak menghentikan chain.\n * array index 0 adalah mainSchemaUrl\n */\nexport async function findRequiredSchemas(mainSchemaUrl, visited = new Set()) {\n    if (visited.has(mainSchemaUrl)) {\n        return Promise.resolve([]);\n    }\n    visited.add(mainSchemaUrl);\n    return fetch(mainSchemaUrl)\n        .then((res) => {\n        if (!res.ok)\n            throw new Error(`Gagal fetch schema: ${mainSchemaUrl}`);\n        return res.text();\n    })\n        .then(async (text) => {\n        const regex = /<[a-zA-Z]{2}:(?:import|include|redefine)[^>]*schemaLocation=\"([^\"]+)\"/g;\n        const matches = Array.from(text.matchAll(regex));\n        const base = new URL(mainSchemaUrl);\n        const nestedUrls = [];\n        for (const match of matches) {\n            try {\n                const resolved = new URL(match[1], base).href;\n                if (!visited.has(resolved))\n                    nestedUrls.push(resolved);\n            }\n            catch (e) {\n                console.warn(\"URL tidak valid:\", match[1]);\n            }\n        }\n        return Promise.all(nestedUrls.map((url) => findRequiredSchemas(url, visited)))\n            .then((nestedSchemasArrays) => {\n            const nestedSchemas = nestedSchemasArrays.flat();\n            return Promise.resolve([{ filename: mainSchemaUrl, contents: text }, ...nestedSchemas]);\n        });\n    })\n        .catch((err) => {\n        console.error(\"findRequiredSchemas error:\", err);\n        // Jangan throw lagi \u2014 tetap resolve agar proses tidak berhenti\n        return Promise.reject([]);\n    });\n}\n/**\n * Ambil URL schema dari atribut `xsi:noNamespaceSchemaLocation`\n * atau `xsi:schemaLocation`.\n */\nexport function extractSchemaLocation(xmlText) {\n    // Cari noNamespaceSchemaLocation\n    const noNsMatch = xmlText.match(/\\b[a-zA-Z0-9]+:noNamespaceSchemaLocation\\s*=\\s*[\"']([^\"']+)[\"']/i);\n    if (noNsMatch)\n        return noNsMatch[1];\n    // Cari schemaLocation (bisa punya banyak pasangan namespace + URL)\n    const schemaLocMatch = xmlText.match(/\\bxsi:schemaLocation\\s*=\\s*[\"']([^\"']+)[\"']/i);\n    if (schemaLocMatch) {\n        // schemaLocation bisa berisi banyak pasangan:\n        // \"ns1 url1 ns2 url2 ...\" \u2192 ambil semua URL yang kelihatan valid\n        const parts = schemaLocMatch[1].trim().split(/\\s+/);\n        const urls = parts.filter(p => /^https?:\\/\\/|\\.xsd$/i.test(p));\n        return urls[0] || null;\n    }\n    // Tidak ditemukan\n    return null;\n}\n/**\n * to check wheter the param is xml text or url\n * @param file url or xml text file\n * @returns\n */\nexport function isXmlLike(file) {\n    if (typeof file !== 'string') {\n        return false; // Not a string\n    }\n    // Check for common XML elements and structure\n    return file.includes('<') && file.includes('>') &&\n        (file.includes('<?xml') || file.includes('</'));\n}\n/**\n * to get xml text from url.\n * @param file url or xml contents\n * @returns xml text\n */\nexport async function getXmlText(file) {\n    if (isXmlLike(file)) {\n        return Promise.resolve(file);\n    }\n    else {\n        const fileurl = (new URL(file, window.location.href)).href;\n        return fetch(fileurl).then(r => r.text());\n    }\n}\n", "import { createMapInputProvider } from \"./provider/MapInputProvider\";\nimport { extractSchemaLocation, findRequiredSchemas, getXmlText } from \"./util/helper\";\nimport { useLibXml2 } from \"./libxml/libxmlloader\";\n/**\n * logic validate xml toward xsd.\n * @param file url or xml contents\n * @param mainSchemaUrl url\n * @returns\n */\nexport async function validateXmlTowardXsd(file, mainSchemaUrl = null, stopOnFailure = true) {\n    const { libxml, ensureLibxmlLoaded } = useLibXml2();\n    let provider = null;\n    const bags = [];\n    // 0) ensure libxml\n    await ensureLibxmlLoaded();\n    // 1). Load xmlText\n    let xmlText;\n    try {\n        xmlText = await getXmlText(file);\n    }\n    catch {\n        console.warn(\"Warning: Failed to fetch xml content\");\n        bags.push({\n            name: \"FetchError\",\n            type: \"xsd\",\n            detail: {\n                message: \"Failed to fetch xml content\",\n                col: 1,\n                line: 1,\n                file: \"\"\n            }\n        });\n        if (stopOnFailure) {\n            return Promise.reject(bags);\n        }\n    }\n    mainSchemaUrl = mainSchemaUrl ?? extractSchemaLocation(xmlText);\n    if (!mainSchemaUrl) {\n        console.warn(\"Warning: Failed to fetch xml content\");\n        bags.push({\n            name: \"FetchError\",\n            type: \"xsd\",\n            detail: {\n                message: \"Failed to get schema location\",\n                col: 1,\n                line: 1,\n                file: \"\"\n            }\n        });\n        if (stopOnFailure) {\n            return Promise.reject(bags);\n        }\n    }\n    // 2). Load required schema\n    let schemas = null;\n    try {\n        schemas = await findRequiredSchemas(mainSchemaUrl);\n    }\n    catch (error) {\n        console.warn(\"Warning: Failed to find required schemas\");\n        bags.push({\n            name: \"FetchError\",\n            type: \"xsd\",\n            detail: {\n                message: \"Failed to find required schemas\",\n                col: 1,\n                line: 1,\n                file: \"\"\n            }\n        });\n        if (stopOnFailure) {\n            return Promise.reject(bags);\n        }\n    }\n    // 3) create provider\n    try {\n        provider = await createMapInputProvider(schemas);\n        provider.register();\n    }\n    catch (error) {\n        console.warn(\"Warning: xmlRegisterInputProvider returned false\");\n        bags.push({\n            name: \"RegisteringProviderError\",\n            type: \"xsd\",\n            detail: {\n                message: \"Failed to create/register provider\",\n                col: 1,\n                line: 1,\n                file: \"\"\n            }\n        });\n        if (stopOnFailure) {\n            return Promise.reject(bags);\n        }\n    }\n    // 4) load XML & main XSD doc (main xsd still parsed from string)\n    const mainXsdText = schemas[0].contents;\n    let xmlDoc;\n    let xsdDoc;\n    try {\n        xmlDoc = libxml().XmlDocument.fromString(xmlText);\n        xsdDoc = libxml().XmlDocument.fromString(mainXsdText);\n    }\n    catch (error) {\n        console.warn(\"Warning: XML and XSD Document fail to parsed\");\n        bags.push({\n            name: \"XMLParseError\",\n            type: \"xsd\",\n            detail: {\n                message: \"Failed to create instance of Xml and Xsd document\",\n                col: 1,\n                line: 1,\n                file: \"\"\n            }\n        });\n        if (stopOnFailure) {\n            provider?.cleanup();\n            return Promise.reject(bags);\n        }\n    }\n    // 5) create validator\n    let validator;\n    try {\n        validator = libxml().XsdValidator.fromDoc(xsdDoc);\n    }\n    catch (error) {\n        console.warn(\"Warning: Failed to create Xsd validator\");\n        bags.push({\n            name: \"XSDValidatorParseError\",\n            type: \"xsd\",\n            detail: {\n                message: \"Failed to create Xsd validator\",\n                col: 1,\n                line: 1,\n                file: \"\"\n            }\n        });\n        if (stopOnFailure) {\n            provider?.cleanup();\n            return Promise.reject(bags);\n        }\n    }\n    // 6) validate\n    try {\n        validator.validate(xmlDoc);\n    }\n    catch (error) {\n        for (const d of error.details) {\n            bags.push({\n                name: \"XMLValidateError\",\n                type: \"xsd\",\n                detail: {\n                    message: d.message || \"XSD Validation failed\",\n                    file: d.file || \"\",\n                    line: d.line || 1,\n                    col: d.col || 1,\n                },\n            });\n        }\n        if (stopOnFailure) {\n            provider?.cleanup();\n            return Promise.reject(bags);\n        }\n    }\n    // 6) cleanup\n    provider?.cleanup();\n    return Promise.reject(bags);\n}\n", "import { validateWellForm } from \"./validateFormWell\";\nimport { validateXmlTowardXsd } from \"./validateTowardXsd\";\n// import ValidatorWorker from \"./worker/validator.worker?worker\";\n// validate.ts (your library)\nexport async function createValidatorWorker() {\n    // dynamically import the worker if bundler supports it\n    // works for Vite and esbuild\n    const WorkerConstructor = (await import(\"./worker/validator.worker?worker\")).default;\n    return new WorkerConstructor();\n}\n/**\n * TBD, akan memvalidate xml berdasarkan namespace\n * tidak berjalan di worker\n * xsi:schemaLocation may contain two xsd, eg. xsi:schemaLocation=\"namespace1 xsd1 namespace2 xsd2\"\n */\nexport async function validateXml(xmlText, mainSchemaUrl = null, stopOnFailure = true) {\n    const errors = [];\n    return validateWellForm(xmlText)\n        .then((validateWellFormInfos) => {\n        errors.push(...validateWellFormInfos);\n        if (!stopOnFailure || (errors.length < 1)) {\n            return validateXmlTowardXsd(xmlText, mainSchemaUrl, stopOnFailure)\n                .then((validateXmlTowardXsdInfos) => {\n                if (validateXmlTowardXsdInfos) {\n                    errors.push(...validateXmlTowardXsdInfos);\n                }\n                return errors;\n            });\n        }\n        return errors;\n    });\n}\n// function reactiveStatus(init: string) {\n//   let value = init;\n//   let listeners: Function[] = [];\n//   return {\n//     get value() {\n//       return value;\n//     },\n//     set value(v) {\n//       value = v;\n//       listeners.forEach(fn => fn(v));\n//     },\n//     reset() {\n//       listeners = [];\n//     },\n//     watch(fn: Function) {\n//       listeners.push(fn);\n//     },\n//     when(predicate: Function) {\n//       return new Promise(resolve => {\n//         if (predicate(value)) resolve(value);\n//         else this.watch((v: any) => predicate(v) && resolve(v));\n//       });\n//     }\n//   };\n// }\n// contoh penggunaan reactiveStatus:\n// const wstatus = reactiveStatus(\"working\");\n// let s1:any = wstatus.when(v => v !== \"working\").then(v => s1 = v);\n// wstatus.value = \"done\"; // \u2705 langsung resolve\nexport function useWorker() {\n    const _responses = new Map();\n    // const validatorWorker = new ValidatorWorker();\n    let validatorWorker;\n    const validatorWorkerCreate = new Promise(async (r) => {\n        validatorWorker = await createValidatorWorker();\n        validatorWorker.onmessage = (e) => {\n            const { id, status, bags } = e.data;\n            if (status) {\n                if (_responses.has(id)) {\n                    const { resolve } = _responses.get(id);\n                    resolve({ id, status, bags });\n                    _responses.delete(id);\n                }\n            }\n            else {\n                const { reject } = _responses.get(id);\n                reject({ id, status, bags });\n                _responses.delete(id);\n            }\n        };\n        validatorWorker.onerror = function (e) {\n            throw new Error(\"Worker error\");\n        };\n        return r(validatorWorker);\n    });\n    const terminate = async () => {\n        if (!validatorWorker)\n            await validatorWorkerCreate;\n        validatorWorker.terminate();\n    };\n    const validate = async (xmlText, mainSchemaUrl, stopOnFailure = true) => {\n        if (!validatorWorker)\n            await validatorWorkerCreate;\n        const id = crypto.randomUUID();\n        return new Promise((resolve, reject) => {\n            _responses.set(id, { resolve, reject });\n            const payload = {\n                id,\n                payload: { xmlText, mainSchemaUrl, stopOnFailure }\n            };\n            validatorWorker.postMessage(payload);\n        });\n    };\n    return {\n        validate, terminate\n    };\n}\n", "// import { ValidationInfo, WorkerResponse } from \"../src/types\";\r\nimport { ValidationInfo, WorkerResponse } from \"../dist/esm/types\";\r\n// import { useWorker, validateXml } from \"../src/validate\";\r\nimport { useWorker, validateXml } from \"../dist/esm/validate\";\r\n\r\n// const fileurl = \"/test/xml_file.xml\";\r\n// const xmlText = await getXmlText(fileurl);\r\n\r\nfunction appendToHTML(idEl: string, errors: ValidationInfo[]) {\r\n  const container = document.getElementById(idEl)\r\n  if (container) {\r\n    errors.forEach((err, i) => {\r\n      const div = document.createElement(\"div\");\r\n      div.className = \"error-item\";\r\n      div.innerHTML = `\r\n<strong>${i + 1}. ${err.name}</strong>\r\n<em>(${err.type})</em>\r\n<br>\r\n  <pre>${err.detail.message.trim()}</pre>\r\n  <small>Line: ${err.detail.line}, Col: ${err.detail.col}</small>\r\n      `;\r\n      container.appendChild(div);\r\n    });\r\n  }\r\n}\r\n\r\nfunction test1() {\r\n  const xmlText =\r\n  `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n  <!DOCTYPE dmodule >\r\n  <dmodule xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:dc=\"http://www.purl.org/dc/elements/1.1/\"\r\n    xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\r\n    xmlns:xlink=\"http://www.w3.org/1999/xlink\" xsi:noNamespaceSchemaLocation=\"https://ferdisap.github.io/schema/s1000d/S1000D_5-0/xml_schema_flat/appliccrossreftable.xsd\">\r\n    <identAndStatusSection></identAndStatusSection>\r\n  </dmodule>`;\r\n  validateXml(xmlText)\r\n    .catch(bags => {\r\n      console.log(bags) // returning array contains object has name:\"XMLValidateError\"\r\n      appendToHTML(\"for_test_1\", bags);\r\n    })\r\n}\r\ntest1()\r\n\r\nasync function test2() {\r\n  const xmlText =\r\n    `<?xml version=\"1.0\" encoding=\"UTF-8\"?>  <!DOCTYPE dmodule >\r\n  <dmodule>\r\n    <identAndStatusSection></identAndStatusSection>\r\n  </dmodule>`;\r\n  const mainSchemaUrl = \"http://www.s1000d.org/S1000D_5-0/xml_schema_flat/appliccrossreftable.xsd\"; // CORS\r\n\r\n  const { validate, terminate } = useWorker()\r\n  validate(xmlText, mainSchemaUrl)\r\n    // never get resolved if the file is valid\r\n    .then((response:WorkerResponse) => {\r\n      const { id, status, bags } = response;\r\n      console.log(id, status, bags) \r\n      appendToHTML(\"for_test_2\", bags);\r\n    })\r\n    .catch((response:WorkerResponse) => {\r\n      const { id, status, bags } = response;\r\n      console.log(id, status, bags)\r\n      appendToHTML(\"for_test_2\", bags); // returning array contains object has name:\"Fetch Error\" because CORS\r\n      terminate()\r\n    })\r\n\r\n}\r\ntest2()\r\n\r\n// expected\r\n/**\r\n[\r\n  {\r\n    name: \"XMLValidateError\",\r\n    type: \"xsd\",\r\n    detail: {\r\n      message: \"Element 'identAndStatusSection': Missing child element(s). Expected is ( dmAddress ).\\\\n\",\r\n      file: \"\",\r\n      line: 3,\r\n      col: 1\r\n    }\r\n  },\r\n  {\r\n    name: \"XMLValidateError\",\r\n    type: \"xsd\",\r\n    detail: {\r\n      message: \"Element 'dmodule': Missing child element(s). Expected is ( content ).\\\\n\",\r\n      file: \"\",\r\n      line: 2,\r\n      col: 1\r\n    }\r\n  }\r\n]\r\n*/\r\n"],
  "mappings": "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",
  "names": ["libxml", "libxml", "libxml"]
}
